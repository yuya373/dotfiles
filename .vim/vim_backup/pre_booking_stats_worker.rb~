require 'csv'

class PreBookingStatsWorker
  include Sidekiq::Worker
  include Sidetiq::Schedulable
  "#"

  recurrence do
    daily.hour_of_day(2)
  end

  def perform
    time = Time.now.beginning_of_day
    pre_bookings = active_pre_bookings(time)

    AdminNotificationMailer.
      kpi(APP_CONFIG["mail"]["info"], "pre_booking stats #{time.to_date}",
          pre_booking_stats(pre_bookings), nil).deliver

    pre_bookings = pre_bookings.where("price > 1")
    AdminNotificationMailer.
      kpi(APP_CONFIG["mail"]["info"], "pre_booking avarage #{time.to_date}",
          pre_booking_avarage(pre_bookings), nil).deliver
  end

  private

  def pre_booking_avarage(pre_bookings)
    c = pre_bookings.count
    avgs = [:price,:minutes,:party].map do |k|
      [k, pre_bookings.sum(k)/c]
    end
    CSV.generate do |csv|
      csv << avgs.map(&:first)
      csv << avgs.map(&:last)
    end
  end

  def pre_booking_stats(pre_bookings)
    accumulates = {
      distance_from_create: ->(e){
        ((e.start_at - e.created_at)/(3600*24)).floor
      },
      day_of_week: ->(e){
        e.start_at.wday
      },
      hour_of_day: ->(e){
        e.start_at.hour
      },
      party: ->(e){
        e.party
      },
      hours: ->(e){
        (e.minutes.to_f / 60).round
      },
      price_per_hour: ->(e){
        ((e.price*60 / e.minutes.to_f)/ 500).round * 500
      },
      listing: ->(e){
        e.listing_id
      }
    }.map do |key, f|
      [key, Hash.new{|h, k| h[k] = 0 }, f]
    end

    pre_bookings.each do |e|
      accumulates.each do |k, h, f|
        index = f.(e)
        next if index < 0
        h[index] += 1
      end
    end

    kpi = ""
    accumulates.each do |k,h,_|
      kpi += "#{k}\n"
      r = h.sort
      kpi += r.map(&:first).join(",") + "\n"
      kpi += r.map(&:last).join(",") + "\n"
      kpi += "\n"
    end
    kpi
  end

  def active_pre_bookings(lt=Time.now)
    bc = '2013-11-24 00:00:00'
    PreBooking.where("created_at > ?", bc).start_at_gteq(bc).
      active.where("created_at <= ?", lt)
  end
end
