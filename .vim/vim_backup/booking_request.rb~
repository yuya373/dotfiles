# == Schema Information
#
# Table name: booking_requests
#
#  id         :integer          not null, primary key
#  listing_id :integer          not null
#  user_id    :integer          not null
#  party      :integer          not null
#  minutes    :integer          not null
#  start_at   :datetime         not null
#  status     :integer          default(0), not null
#  created_at :datetime
#  updated_at :datetime
#
# Indexes
#  listing_id  (listing_id)
#  user_id     (user_id)
#

class BookingRequest < ActiveRecord::Base
  include HourToMinutes
  belongs_to :listing
  belongs_to :user

  STATUSES = {
    pending: 0,
    accept: 1,
    deny: 2,
    convert: 3,
  }.freeze

  scope :pruning, ->{
    where arel_table[:created_at].gt(1.week.ago)
  }
  scope :pending, ->{
    where status: STATUSES[:pending]
  }
  scope :convertable, ->(user_id, start_at){
    user_is(user_id).where(start_at: start_at).
    where(status: STATUSES[:accept])
  }
  scope :user_is, ->(user_id){
    where(user_id: user_id)
  }
  scope :start_at_gteq, ->(start_at){
    where arel_table[:start_at].gteq(start_at)
  }
  scope :start_at_lteq, ->(start_at){
    where arel_table[:start_at].lteq(start_at)
  }

  class << self
    def find_or_create(listing, params)
      p start_at = DateTime.parse(params[:start_at])
      p end_at = start_at.since(params[:hours].to_i * 3600)
      bod = start_at.beginning_of_day
      eod = start_at.end_of_day

      same_day_request = where(listing_id: listing.id).
        user_is(params[:user_id]).start_at_gteq(bod).start_at_lteq(eod)

      if same_day_request.present?
        same_day_request.each do |old|
          if start_at.between?(old.start_at, old.end_at)
            old.update!(params)
            return old
          elsif old.start_at.between?(start_at, end_at)
            old.update!(params)
            return old
          end
        end
        listing.booking_requests.create!(params)
      else
        listing.booking_requests.create!(params)
      end
    end
  end


  def pending?
    status == STATUSES[:pending]
  end

  def acceptable?(listing)
    RoomAvail.covering_room_schedules(listing, start_at, end_at).
      available.exists?
  end

  def add_available(listing)
    transaction do
      add_schedule(listing, RoomSchedule::STATUSES[:available])
      deny
    end
  rescue ActiveRecord::RecordInvalid => e
    logger.warn e
  end

  def add_unailable(listing)
    transaction do
      add_schedule(listing, RoomSchedule::STATUSES[:unavailable])
      accept
    end
  rescue ActiveRecord::RecordInvalid => e
    logger.warn e
  end

  def end_at
    start_at + minutes.minutes
  end

  def convert
    update(status: STATUSES[:convert])
  end

  private

  def add_schedule(listing, status)
    room_calendar = RoomCalendar.
      find_or_create_a_day(listing, start_at.to_date, lock=true)
    room_calendar.
      add_range_schedule(start_at, listing.add_cleaning_minutes(end_at), status)
  end

  def deny
    update!(status: STATUSES[:deny])
  end

  def accept
    update!(status: STATUSES[:accept])
  end
end
