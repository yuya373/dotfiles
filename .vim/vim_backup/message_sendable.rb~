module MessageSendable
  extend ActiveSupport::Concern

  included do
    has_many :messages, as: :sender
    has_many :receipts, as: :receiver
  end

  def unread_count
    count = Conversation.joins(:messages => :receipt).
      merge(Receipt.receiver_is(self).unread).distinct.count
  end

  def unread_count_str
    unread_count > 0 ? unread_count : 0
  end

  def has_unread?
    false
    return true if unread_count > 0
  end

  def inbox
    Conversation.inbox(self)
  end

  def sentbox
    Conversation.sentbox(self)
  end

  def send_message(receiver, body, subject, options={})
    conv_subject = options[:conv_subject]
    association = options[:association]
    notify = options[:notify]

    conv_subject = conv_subject || subject
    conv = create_conversation(conv_subject, association)
    message = build_message(conv, body, self, subject)
    message.deliver(receiver, notify)
  end


  def reply(conv, body, options={}notify=nil subject=nil, attachment=nil)
    subject = options[:subject]
    notify = options[:notify]
    conv.touch
    subject = "RE:#{conv.subject}" if subject.blank?
    message = build_message(conv, body, self, subject)
    receiver = define_receiver(conv)
    message.deliver(receiver, notify)
  end

  private

  def create_conversation(subject, association)
    conv = Conversation.create(subject: subject)
    if association.is_a?(PreBooking)
      association.create_pre_booking_conversation(conversation_id: conv.id)
    elsif association.is_a?(BookingRequest)
      association.create_booking_request_conversation(conversation_id: conv.id)
    end
    conv
  end

  def define_receiver(conv)
    return conv.last_message_for(self).sender if conv.last_message_for(self)
    conv.original_message.receiver
  end

  def build_message(conv, body, sender, subject)
    conv.messages.build(body: body, sender: self, subject: subject)
  end
end
