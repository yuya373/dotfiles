/** @jsx React.DOM */
define([
    "react",
    "components/mixins/AjaxMixin",
    "components/mixins/SchedulerAjaxMixin",
    "components/mixins/SchedulerBlockMixin",
    "components/mixins/SlotMixin",
    "components/mixins/InteractiveSlotMixin",
    "components/pc/SchedulePrompt",
    "components/mixins/SchedulerHelper",
    "components/mixins/DatetimeHelper",
    "components/pc/scheduler/SlotPriceViewer",
    "components/mixins/ProviderSlotMixin"
    ], function(React, AjaxMixin, SchedulerAjaxMixin, SchedulerBlockMixin, SlotMixin, InteractiveSlotMixin, SchedulePrompt, SchedulerHelper, DatetimeHelper, SlotPriceViewer, ProviderSlotMixin) {
  /*
   * Scheduler Slots
   */
  var SchedulerSlots = React.createClass({
    mixins: [SchedulerAjaxMixin, SchedulerBlockMixin, AjaxMixin, SlotMixin, InteractiveSlotMixin, SchedulerHelper, ProviderSlotMixin],
    getInitialState: function() {
      return {
        days: [],
        priceTables: this.makePriceTables()
      };
    },
    render: function() {
      var style = {"height":"2400px"};  //FIXME LATER
      return (
        <div className="scheduler-event-canvas" style={style}>
          <SchedulePrompt ref="schedulePrompt" onSubmit={this.addNewState} onCancel={this.resetTemp} />
          <SlotPriceViewer ref="priceViewer" />
        </div>
      );
    },
    makePriceTables: function() {
      if(!this.timeTableKeys) {
        this.timeTableKeys = DatetimeHelper.timeTableKeys();
      }
      var priceTables = {},
          keys        = _.keys(this.props.pricePlans);
      for(var i=0;i<keys.length;i++) {
        priceTables[keys[i]] = this.makePriceTable(keys[i]);
      }
      // console.log("priceTables", priceTables);
      return priceTables;
    },
    makePriceTable: function(pricePlanId) {
      var pricePlan     = this.props.pricePlans[pricePlanId],
          timeTable     = {},
          timeTableKeys = this.timeTableKeys,
          prices        = pricePlan.prices,
          keyLength     = timeTableKeys.length;
      prices.map(function(price) {
        var startsInt = DatetimeHelper.timeLabelToInt( price.startsAt ),
            endsInt   = DatetimeHelper.timeLabelToInt( price.endsAt );
        for(var i =0; i<keyLength; i++) {
          var timeTableKey = timeTableKeys[i],
              timeInt      = parseInt(timeTableKey);
          if(timeInt >= startsInt && timeInt < endsInt) {
            timeTable[timeTableKey] = parseInt(price.price);
          }
          else {
            if(!_.has(timeTable, timeTableKey) ) {
              timeTable[timeTableKey] = -1;
            }
          }
        }
      });
      return timeTable;
    },
    componentDidMount: function() {
      // console.log("SchedulerSlots - componentDidMount");
      this.prepareSlotMixin();
      this.adjustScrollTop(this.props.defaultTime);
      this.$canvas = $(this.getDOMNode());
      this.$scrollCanvas = $(".scheduler-rows-shell");
      this.placeBlocks();



//      this.$canvas.bind("mousedown", this.handleMouseDown).bind("mouseup", this.handleMouseUp);
      this.$canvas.bind("mousedown", this.handleMouseDown);

      // Delegate: ".block-remove" -> removeSchedule
      this.$canvas.on("click", ".block-remove", this.removeSchedule);
      // Delegate:

      this.$canvas.on("mouseover", ".block-available", this.showPrice);
      this.$canvas.on("mouseout",  ".block-available", this.hidePrice);

      // Delegate: Draggable
      var t = this;
      this.$canvas.on("mousedown", ".block-available, .block-unavailable", function(event) {
        $(this).draggable({
          axis: "y",
          scroll: true,
          distance: t.props.slotHeight,
          dynamic: false,
          start: t.handleDragStart,
          stop: t.handleDragStop
        }).resizable({
          minHeight: t.props.slotHeight,
          minWidth: t.props.slotWidth,
          maxWidth: t.props.slotWidth,
          start: t.handleResizeStart,
          resize: t.handleResizeProcess,
          stop: t.handleResizeStop
        });
      });
    },
    weekDidChange: function(days) {
      // this.$canvas.empty();
      this.adjustScrollTop(this.props.defaultTime);
      this.$canvas.find(".slot-block").remove();
      this.placeBlocks();
    },
    didPricePlanUpdate: function(pricePlan) {
      // Update price tables
      var priceId = pricePlan.id,
          priceTable  = this.makePriceTable(priceId),
          priceTables = _.extend({}, this.state.priceTables),
          t = this;
      priceTables[priceId] = priceTable;
      this.setState({"priceTables":priceTables}, function() {
        // t.props.days.map(function(day, index) {
        //   if(day.priceId != priceId) { return; }
        //   t.updateBlockPriceForDay(day, index);
        // });
      });
    },
    // updateBlockPriceForDay: function(day, dayIndex) {
    //   var $blocks = this.$canvas.find("." + this.getStateClass("available") + "[dayIndex="+dayIndex+"]"),
    //       priceTable = this.state.priceTables[day.priceId];
    //   $blocks.each(function(index) {
    //     var block = $blocks[index],
    //         $b    = $(block),
    //         startsAt = DatetimeHelper.timeLabelToFourChars( $b.attr("startsat") ),
    //         newPrice = priceTable[startsAt];
    //     $b.find(".price").text(newPrice + "円/時間");
    //   });
    // },
    showPrice: function(event) {
      var $target    = $(event.target),
          dayIndex   = $target.attr("dayIndex");
      if(_.isUndefined(dayIndex)) { return; }

      // console.log("showPrice", event);
      var day        = this.props.days[dayIndex],
          priceTable = this.state.priceTables[day.priceId],
          pos        = $target.position(),
          style      = {"top": (pos.top) + "px" },
          from       = pos.top,
          to         = from + $target.height(),
          viewerW    = 250;

      if(dayIndex <= 3) {
        style["left"] = (pos.left + this.props.slotWidth + 5) + "px";
      }
      else {
        style["left"] = (pos.left - viewerW - 5) + "px";
      }

      this.refs.priceViewer.show({
        "style"     : style,
        "startsAt"  : this.pixelToTimeLabel( from ),
        "endsAt"    : this.pixelToTimeLabel( to ),
        "priceTable": priceTable
      });
    },
    hidePrice: function(event) {
      this.refs.priceViewer.dismiss();
    },
    onPromptMount: function() {
      // console.log("onPromptMount");
    },
    resetTemp: function() {
      // console.log("resetTemp");
      this.refs.schedulePrompt.dismiss();
      this.$newBlock.remove();
    },
    addNewState: function(data) {
      this.ajaxPost({
        "api": this.props.apiAddSchedule,
        "data": _.extend(data, {"listingId":this.props.listingId}),
        "callback": this.onAddNewState,
        "messageCallback": this.props.showMessage,
        "showSuccessMessage": true
      });
    },
    onAddNewState: function(params) {
      // console.log("onAddNewState");
      var data = params.datasource,
          date = data.date ? parseInt(data.date) : null,
          dayIndex;

      if(data.result != "success") {
        return;
      }

      // Get day index
      dayIndex = this.getDayIndexFromDays(this.props.days, date);
      if(dayIndex == -1) { console.log("dateIndex is -1"); return; }
      this.addStateBlock(data.slot, dayIndex);  // Add block
      this.resetTemp();  // Remove prompt
    },
    removeSchedule: function(event) {
      console.log("removeSchedule");
      var $block = $(event.target).parent().parent(),
          dayIndex = $block.attr("dayIndex"),
          date     = this.props.days[dayIndex].date,
          top      = $block.position().top,
          bottom   = top + $block.height(),
          startsAt = this.pixelToTimeLabel(top),
          endsAt   = this.pixelToTimeLabel(bottom),
          data     = {
            "date"      : date,
            "startsAt"  : startsAt,
            "endsAt"    : endsAt,
            "listingId" : this.props.listingId
          },
          t = this;
      this.ajaxPost({
        "api"      : this.props.apiRemoveSchedule + "/" + date, //TODO start_atも含める
        "data"     : _.extend(data, {"_method":"delete"}),
        "callback" : t.onRemoveSchedule,
        "messageCallback": this.props.showMessage,
        "showSuccessMessage": true
      });
    },
    onRemoveSchedule: function(params) {
      console.log("onRemoveSchedule");
      var obj  = this.onSchedulerAjaxPost(params),
          data = obj.data,
          date = obj.date,
          result = obj.result;
      if(!result) { return; }
      this.getInteractiveBlock(this.getDayIndexByDate(date), data.slot.startsAt).remove();
      this.updateSlotsForDay(date)
    },
    // Called from InteractiveSlotMixin:callUpdateSchedule
    updateSchedule: function(params) {
      console.log("updateSchedule");
      var date = this.props.days[params.dayIndex].date;
      var data = {
            "date"       : date,
            "state"      : params.state,
            "startsAt"   : params.startsAt,
            "endsAt"     : params.endsAt,
            "listingId"  : this.props.listingId,
            "original"   : {
              "date"     : date,
              "startsAt" : params.origStartsAt,
              "endsAt"   : params.origEndsAt,
              "position" : params.origPosition,
              "size"     : params.origSize
            }
          };
      // console.table([
      //   {
      //     "startsAt": params.origStartsAt + "->" + params.startsAt,
      //     "endsAt": params.origEndsAt + "->" + params.endsAt
      //   }
      // ]);
      this.ajaxPost({
        "api": this.props.apiUpdateSchedule + "/" + date,
        "data": _.extend(data, {"_method":"patch"}),
        "callback": this.onUpdateSchedule,
        "messageCallback": this.props.showMessage,
        "showSuccessMessage": true
      });
    },
    onUpdateSchedule: function(params) {
      console.log("onUpdateSchedule");
      var obj  = this.onSchedulerAjaxPost(params),
          data = obj.data,
          date = obj.date,
          result = obj.result;
      // console.table([
      //   {
      //     "startsAt": data.original.startsAt + "->" + data.startsAt,
      //     "endsAt": data.original.endsAt + "->" + data.endsAt
      //   }
      // ]);
      // console.log("data", data);
      if(!result) { // Revert its size, position and state
        $block = this.getInteractiveBlock(this.getDayIndexByDate(date), data.original.startsAt);
        if(original.size) { // has value only if action == "resize"
          $block.height(data.original.size.height);
        }
        $block.css("top", data.original.position.top + "px");
        return;
      }
      /* No need to do: "update height, size" (done by user action BEFORE ajax post) */
      // Update "startsAt" attribute
      if(data.startsAt != data.original.startsAt) {
        $block = this.getInteractiveBlock(this.getDayIndexByDate(date), data.original.startsAt);
        $block.attr("startsAt", data.startsAt);
      }
    },
    updateSlotsForDay: function(day) {
      console.log("updateSlotsForDay");
      var dayIndex = this.getDayIndexFromDays(this.props.days, day.date);
      this.$canvas.find(".slot-block[dayIndex="+dayIndex+"]").remove();
      this.placeBlocksForDay(day, dayIndex);
    }
  });

  return SchedulerSlots;
});
