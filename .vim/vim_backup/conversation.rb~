# == Schema Information
#
# Table name: conversations
#
#  id         :integer          not null, primary key
#  subject    :string(255)      not null
#  created_at :datetime
#  updated_at :datetime
#

class Conversation < ActiveRecord::Base
  has_many :messages
  validate :subject, presence: true

  scope :inbox, ->(usr){
    # joins(:messages => :receipt).merge(Receipt.receiver_is(usr)).distinct
    joins(:messages).merge(Message.messages_for(usr)).distinct.order(created_at: :desc)
  }

  scope :sentbox, ->(usr){
    joins(:messages).merge(Message.sender_is(usr)).distinct.order(created_at: :desc)
  }

  def last_message
    messages.order(created_at: :desc).first 
  end

  def sender_is(usr)
    messages.merge(Message.sender_is(usr).conversation_is(self)).order(created_at: :desc)
  end

  def last_sender_is(usr)
    sender_is(usr).order(created_at: :desc).first
  end

  def messages_for(usr)
    messages.merge(Message.messages_for(usr).where conversation_id: self.id).readonly(false)
  end

  def last_message_for(usr)
    messages_for(usr).order(created_at: :desc).first 
  end

  def mark_as_read(usr)
    receipts = Receipt.unread.conversation_is(self).
      merge(Message.messages_for(usr)).readonly(false)

    receipts.map(&:mark_as_read)
  end

  def originator
    # messages.order(created_at).first.sender
    original_message.sender
  end

  def original_message
    messages.unscoped.order(created_at).first
  end

  def pre_booking
    PreBooking.joins(:pre_booking_conversation).merge(PreBookingConversation.where(conversation_id: self.id)).first
  end

  def is_unread?(usr)
    last_message_for(usr).try(:is_unread?)
  end

  def status(usr)
    is_unread?(usr) ? 'unread' : 'read'
  end
end
