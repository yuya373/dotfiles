# == Schema Information
#
# Table name: listings
#
#  id                          :integer          not null, primary key
#  provider_id                 :integer          not null
#  category_id                 :integer          not null
#  is_display                  :boolean          default(FALSE), not null
#  is_approved                 :boolean          default(FALSE), not null
#  title                       :string(255)      not null
#  thumb                       :string(255)
#  capacity                    :integer          not null
#  square                      :integer          not null
#  desc                        :string(255)      not null
#  price                       :integer          default(0), not null
#  created_at                  :datetime
#  updated_at                  :datetime
#  email                       :string(255)      not null
#  tel                         :string(255)      not null
#  acceptable_from_now_minutes :integer          default(0), not null
#  min_booking_minutes         :integer          not null
#  score                       :integer          default(0), not null
#
# Indexes
#
#  provider_id_and_title  (provider_id,title) UNIQUE
#

class Listing < ActiveRecord::Base
  belongs_to :provider
  belongs_to :category

  has_one :booking_status, dependent: :destroy
  has_one :listing_station, ->{ ListingStation.access_minutes_asc },
  class_name: :ListingStation
  has_one :listing_setup, dependent: :destroy
  has_one :note, dependent: :destroy
  has_one :station, through: :listing_station, source: :station
  has_one :mail_template, dependent: :destroy
  has_one :featured_photo, class_name: :Photo
  has_one :listing_agreement, dependent: :destroy
  has_one :listing_cancellation_policy, dependent: :destroy
  has_one :listing_city, dependent: :destroy
  has_one :listing_description, dependent: :destroy
  has_one :listing_location, dependent: :destroy

  has_many :pre_settlements, dependent: :delete_all
  accepts_nested_attributes_for :pre_settlements, allow_destroy: true,
  reject_if: proc{|attrs| attrs["description"].blank? }

  has_many :booking_requests
  has_many :calendar_configurations, dependent: :delete_all
  has_many :collections, through: :listing_collections
  has_many :discount_plans, dependent: :delete_all
  has_many :equipments, through: :listing_equipments
  has_many :featured_listing_equipments, ->{ ListingEquipment.featured },
  class_name: :ListingEquipment
  has_many :featured_equipments, through: :featured_listing_equipments, source: :equipment
  has_many :listing_collections, dependent: :delete_all
  has_many :listing_equipments, dependent: :delete_all
  has_many :listing_stations, dependent: :delete_all
  has_many :listing_stocks
  has_many :listing_stocks_2w, ->{ ListingStock.recent }, class_name: ListingStock
  has_many :listing_usages, dependent: :delete_all
  has_many :photos, dependent: :destroy
  has_many :pre_bookings
  has_many :price_plans, dependent: :delete_all
  has_many :reviews
  has_many :room_calendars
  has_many :room_schedules
  has_many :stations, through: :listing_stations
  has_many :usages, through: :listing_usages
  has_many :alien_bookings

  mount_uploader :thumb, ThumbUploader

  accepts_nested_attributes_for :calendar_configurations
  accepts_nested_attributes_for :listing_equipments, allow_destroy: true,
  reject_if: proc{|attrs| attrs["equipment_id"].blank? }
  accepts_nested_attributes_for :listing_stations, allow_destroy: true,
  reject_if: proc{|attrs| attrs["station_id"].blank? }
  accepts_nested_attributes_for :listing_usages, allow_destroy: true,
  reject_if: proc{|attrs| attrs["usage_id"].blank? }
  accepts_nested_attributes_for :photos, allow_destroy: true,
  reject_if: proc{|attrs| attrs["image"].blank? }
  accepts_nested_attributes_for :note, allow_destroy: true
  accepts_nested_attributes_for :mail_template,
  reject_if: proc{|attr| attr["content"].blank?}
  accepts_nested_attributes_for :listing_setup
  accepts_nested_attributes_for :listing_agreement,
  reject_if: proc{|attr| attr["content"].blank?}
  accepts_nested_attributes_for :listing_cancellation_policy,
  reject_if: proc{|attr| attr["content"].blank?}
  accepts_nested_attributes_for :listing_description,
  reject_if: proc{|attr| attr["content"].blank?}
  accepts_nested_attributes_for :listing_location

  validates :desc, presence: true, length: {in: 10..255 }
  validates :title, presence: true, length: {in: 3..255 }, uniqueness: {scope: :provideraaa_id}
  validates :capacity, numericality: {only_integer: true, greater_than: 0}
  validates :square, numericality: {only_integer: true, greater_than: 0}
  validates :tel, format: { with: /\A[0-9-]+\z/ }
  validates :email, presence: true, format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i }
  validates :min_booking_minutes, numericality: {only_integer: true, greater_than_or_equal_to: 60}

  before_validation :strip_whitespace

  scope :header_eagerloads, ->{
    includes(:listing_station => :station)
  }
  scope :list_eagerloads, ->{
    header_eagerloads.includes(:featured_equipments,:featured_photo)
  }
  scope :detail_eagerloads, ->{
    includes(:listing_stations => {:station => :line},
             :listing_usages => :usage,
             :listing_equipments => :equipment)
  }
  scope :price_asc, ->{
    default_order.sort_order(:price, :asc)
  }
  scope :sort_order, ->(key, seq){
    order arel_table[key].send(seq)
  }
  scope :default_order, ->{
    sort_order(:score, :asc)
  }
  scope :published, ->{
    where(is_display: true).approved_is(true).where(arel_table[:price].gt(0))
  }
  scope :approved_is, ->(is_approved){
    where(is_approved: is_approved)
  }
  scope :category_is, ->(category_id){
    return if category_id.blank?
    where(category_id: category_id)
  }
  scope :listing_sort, ->(item,direction){
    order(item + ' ' + direction)
  }
  scope :price_plan_eager_load, ->{
    includes(:price_plans => :price_plan_timetables)
  }
  scope :capacity_gteq, ->(capacity){
    where arel_table[:capacity].gteq(capacity) if 0 < capacity
  }
  scope :capacity_lteq, ->(capacity){
    where arel_table[:capacity].lteq(capacity) if 0 < capacity
  }
  scope :capacity_between, ->(min, max){
    capacity_gteq(min).capacity_lteq(max)
  }
  scope :capacity_match, ->(min, max){
    if min > 0 && max > 0
      capacity_between(min, max)
    elsif min > 0
      capacity_gteq(min)
    end
  }
  scope :price_gteq, ->(price){
    where arel_table[:price].gteq(price) if 0 < price
  }
  scope :price_lteq, ->(price){
    where arel_table[:price].lteq(price) if 0 < price
  }
  scope :price_between, ->(min, max){
    price_gteq(min).price_lteq(max)
  }
  scope :price_match, ->(min, max){
    if min > 0 && max > 0
      price_between(min, max)
    elsif min > 0
      price_gteq(min)
    end
  }

  scope :acceptable_from_now_minutes_lteq, ->(minutes){
    col = arel_table[:acceptable_from_now_minutes]
    where col.gt(0).and(col.lteq(minutes))
  }
  scope :min_booking_minutes_lteq, ->(minutes){
    return if minutes.blank? || minutes <= 0
    where arel_table[:min_booking_minutes].lteq(minutes)
  }
  scope :joins_usage, ->(usage_id){
    return if usage_id.blank?
    joins(:listing_usages).merge(ListingUsage.usage_id_is(usage_id))
  }
  scope :joins_equipment, ->(equipment_id){
    return if equipment_id.blank?
    joins(:listing_equipments).merge(ListingEquipment.equipment_id_is(equipment_id))
  }
  scope :available_between, ->(from, to){
    return if from.blank? || to.blank?
    joins(:room_schedules).
    merge(RoomSchedule.pruning.start_at_lteq(from).end_at_gteq(to).
          available.distinct(:listing_id))
  }
  scope :featured, ->{
    where id: [33,1,38, 39,61,46, 52,114,59, 43,177,49]
  }

  after_create do
    create_booking_status
  end

  class << self
    def to_listing_id_price(listing_ids, from, to)
      return if !(from && to)
      return if to - from <= RoomSchedule::MIN_SCHEDULE_SEC
      RoomCalendar.listing_id_is(listing_ids).
        for_price(from.to_date).map do |e|
        [e.listing_id, e.range_price(from, to)]
      end
    end
  end

  def time_available_from_now
    return Date.tomorrow.to_time if acceptable_from_now_minutes == 0
    Time.now + acceptable_from_now_minutes.minutes
  end

  def price
    r = read_attribute(:price)
    return r if r > 0
    update_price_cache
  end

  def update_price_cache
    return 0 if price_plans.blank?
    PricePlan.min_price(price_plans).tap do |e|
      self.update_attribute(:price, e)
    end
  end

  def note
    super || build_note
  end

  def mail_template
    super || build_mail_template
  end

  def listing_agreement
    super || build_listing_agreement
  end

  def listing_description
    super || build_listing_description
  end

  def listing_cancellation_policy
    super || build_listing_cancellation_policy
  end

  def listing_location
    super || build_listing_location
  end

  def published?
    is_approved? && is_display?
  end

  def build_calendar_configurations
    calendar_configurations.presence ||
      CalendarConfiguration.build_calendar_configurations(self)
  end

  def calendar_default_time
    calendar_configurations.first.try :open_at
  end

  def setup_done?
    @setup_done ||= listing_setup.try :is_done?
  end

  def sales_gurantee?
    listing_setup.try(:is_sales_guarantee?)
  end

  def neighborhood_listings
    g_stations = Station.where(station_g_cd: station_g_cds)
    Listing.joins(:stations).merge(g_stations).distinct
  end

  def has_agreement?
    !!listing_agreement.try(:content)
  end

  def has_listing_description?
    !!listing_description.try(:content)
  end

  def has_cancellation_policy?
    !!listing_cancellation_policy.try(:content)
  end

  def min_booking_hours(hours)
    [hours,min_booking_minutes/60].max
  end

  #TODO cache
  def station_name
    @station_name ||= listing_station.station.station_name
  end

  def neighborhoods
    Neighborhood.station_g_cd_is(station_g_cds)
  end

  def pickup_reviews
    @pickup_reviews ||= reviews.order(updated_at: :desc).limit(3)
  end

  def add_cleaning_minutes(end_at)
    end_at + listing_setup.cleaning_minutes.minutes
  end

  def stock_score
    listing_stocks_2w.to_a.sum(&:minutes) > 0 ? 0 : 100
  end

  def long_description
    listing_description.try(:content)
  end

  private

  def station_g_cds
    stations.pluck(:station_g_cd).uniq
  end

  def strip_whitespace
    [:title, :desc].each do |sym|
      self[sym] = self[sym].try(:strip)
    end
  end
end
